# Анализ производительности и оптимизация хеш-таблицы с использованием x86_64 assembly

## Описание
В данной работе проводится исследование быстродействия хеш-таблицы и оптимизация некоторых ее составляющих для получения максимального выигрыша в скорости. Конечной целью является получение информации об "узких местах" системы и способах преодоления этих ограничений с испольщованием минимально возможного количества платформозависимого кода.

## Установка и сборка
Рекомендуемым способом установки является клонирование репозитория [github](https://github.com/Iprime111/HashTableBenchmark) и сборка при помощи утилиты [cmake](https://cmake.org/). В примере ниже для компиляции используется система сборки [ninja](https://ninja-build.org/) и компилятор [gcc 13.2](https://gcc.gnu.org/).

```bash
> git clone git@github.com:Iprime111/HashTableBenchmark.git
> cd HashTableBenchmark
> git submodule update --init --remote --recursive
> mkdir build && cd build
> cmake .. -DCMAKE_BUILD_TYPE=Release -GNinja
> ninja
> ./bin/HashTableBenchmark
```

> [!IMPORTANT]
> Данная программа предназначена для сборки и запуска на устройствах с POSIX-совместимыми операционными системами, работающими на процессорах с архитектурой intel x86_64 tigerlake (тесты проводились на процессоре intel i7-1165g7 и arch linux)

## Хеш-таблица
### Принцип работы

Для ускорения доступа к данным (по сравнению с линейным поиском) зачастую применяется структура данных, исследуемая в этой работе. Основным принципом работы является вычисления хеша каждого добавленного элемента и использование полученного значения для адресации по массиву с данными. В результате, при использовании правильных алгоритмов хеширования и размера таблицы, можно добиться доступа к данным и их записи за константное время. Ниже приведена упрощенная схема работы хеш таблицы:

![Хеш-таблица](./doc/HashTable.png)\
[*Источник*](https://alextoolsblog.blogspot.com/2019/12/hash-map.html)

### Разрешение коллизий
При работе с хеш-таблицей может возникнуть ситуация, называемая коллизией, когда хеши двух добавленных объектов оказываются одинаковыми. Причиной этого является ограниченность диапазона значений хеш-функции и размера таблицы. Существует множество способов разрешения коллизий (т.е. определения адресов в памяти для объектов с одинаковыми хешами). В исследуемой библиотеке используется следующий: в каждой ячейке таблицы располагается двусвязный список значений. При каждом доступе к ячейке производится линейный поиск по списку, что позволяет находить значения даже при коллизии. Может показаться, что такой метод увеличивает алгоритмическую сложность нахождения/добавления элемента до линейной, однако, при равномерном распределении значений хеша и достаточном размере таблицы, количество элементов в каждом из списков пренебрежимо мало и время доступа может считаться константным.

### Коэффициент заполнения
Одной из величин, характеризующих состояние хеш-таблицы, является **коэффициент заполнения** (англ. load factor), рассчитывающийся, как частное количества элементов в таблице и количества ячеек. От него напрямую зависит скорость поиска элемента, однако не стоит забывать, что **load factor отражает лишь среднее значение заселенности таблицы**, не показвая при этом равномерность распределения элементов по ячейкам. Таким образом, в ситуациях, когда в первой ячейке таблицы размером `100` ячеек находится `200` элементов и, когда эти `200` элементов равномерно распределены по всем ячейкам, коэффициент заполнения будет одинаков и равен `2`. При этом скорость работы структуры данных будет разительно отличаться. Этот пример показывает недопустимость оценки быстродействия хеш-таблицы по одному лишь параметру load factor, что в дальнейшем будет еще неоднократно продеионстрировано.

> [!NOTE]
> В работе используется специально написанная реализация хеш-таблицы, доступная в отдельном [репозитории](https://github.com/Iprime111/HashTable) на github

## Анализ хеш-функций 
В первой части данной работы исследовано поведения различных хеш-функций при использовании в хеш-таблице.

### Параметры тестирования
В тестах использовалась хеш-таблица, хранящая принимающая структуры, каждая из которых состоит из строки и ее длины. В качесте датасета был взят текст книги "Преступление и наказание", предварительно очищеный от всех знаков препинания (кроме апострофов) и приведенный к нижнему регистру. Размер таблицы (`1499` ячеек) был подобран так, чтобы load factor составлял `~6-7` элементов на ячейку. Число `1499` выбрано т.к. оно простое, а значит рамер таблицы гарантировано не будет кратен периоду хеш-функции, что позволяет избежать случаев, когда пики распределения значений хеша накладываются друг на друга.

### Методика измерений
В каждом из тестов хеш-таблица заполняется различными словами, а затем количество слов в каждой ячейке экспортируется, как csv файл, который в дальнейшем используется для построения гистограмм.

> [!NOTE]
> Для заполнения таблицы используются **только уникальные** слова (каждое встречается не более одного раза)

### Измерения
Ниже приведены измерения для 7 различных хеш-функций:

#### Всегда 0

- **Описание:**  Всегда возвращает 0
- **Дисперсия:** `61133.2`
- **Код:**
```c++
inline uint32_t OnlyZeroHash (WordData *word) {
    return 0;
}

```
- **Распределение:**

![OnlyZero](./doc/OnlyZero.png)

#### Первая буква

- **Описание:**  Возвращает ascii-код первой буквы
- **Дисперсия:** `3662.8`
- **Код:** 
```c++
inline uint32_t FirstLetterHash (WordData *word) {
    return (uint32_t) word->word [0];
}

```
- **Распределение:**

![OnlyZero](./doc/FirstLetter.png)

#### Длина слова

- **Описание:**  Возвращает длину слова
- **Дисперсия:** `7150.8`
- **Код:**
```c++
inline uint32_t WordLengthHash (WordData *word) {
    return (uint32_t) word->length;
}
```
- **Распределение:**

![OnlyZero](./doc/WordLength.png)

#### Нормализованная контрольная сумма

- **Описание:**  Возвращает сумму ascii-кодов букв слова, деленную на длину слова
- **Дисперсия:** `6328.9`
- **Код:**
```c++
inline uint32_t NormalizedChecksumHash (WordData *word) {
    uint32_t checksum = 0;

    for (size_t letterIndex = 0; letterIndex < word->length; letterIndex++) {
        checksum += (uint32_t) word->word [letterIndex];
    }

    return checksum / (uint32_t) word->length;
}
```
- **Распределение:**

![OnlyZero](./doc/NormalizedChecksum.png)

#### Контрольная сумма (при малом размере таблицы)

- **Описание:**  Возвращает сумму ascii-кодов букв слова
- **Дисперсия:** `1512.5`
- **Код:**
```c++
inline uint32_t ChecksumHash (WordData *word) {
    uint32_t checksum = 0;

    for (size_t letterIndex = 0; letterIndex < word->length; letterIndex++) {
        checksum += (uint32_t) word->word [letterIndex];
    }

    return checksum;
}
```
- **Распределение:**
![OnlyZero](./doc/ChecksumShort.png)

#### Контрольная сумма (при стандартном размере таблицы)
- **Описание:**  Повторяет предыдущий пункт
- **Дисперсия:** `78.7`
- **Код:** Повторяет предыдущий пункт

- **Распределение:**
![OnlyZero](./doc/Checksum.png)

#### Циклический сдвиг вправо
- **Описание:**  реализует алгоритм циклического сдвига вправо (ror hash)
- **Дисперсия:** `70.8`
- **Код:**
```c++
inline uint32_t RorHash (WordData *word) {
    uint32_t hash = 0;

    for (size_t charIndex = 0; charIndex < word->length; charIndex++) {
        hash = ((hash >> 1) | (hash << (sizeof (hash) - 1) )) ^ ((uint32_t) word->word [charIndex]);
    }

    return hash;
}
```
- **Распределение:**

![OnlyZero](./doc/Ror.png)

#### Циклический избыточный код
- **Описание:**  реализует алгоритм crc32
- **Дисперсия:** `6.3`
- **Код:**
```c++
inline uint32_t Crc32Hash (WordData *word) {
    uint32_t hash = 0xFFFFFFFF;
    uint32_t mask = 0;

    for (size_t byteIndex = 0; byteIndex < word->length; byteIndex++) {

        uint32_t byte = (uint32_t) word->word [byteIndex];
        hash = hash ^ byte;

        for (int bitIndex = 7; bitIndex >= 0; bitIndex--) {
            mask = -(hash & 1);
            hash = (hash >> 1) ^ (0xEDB88320 & mask);
        }
    }

    return ~hash; 
}
```
- **Распределение:**

![OnlyZero](./doc/Crc32.png)

### Наложение периодов
Наряду с остальными хеш-функциями, в сравнении участвовала функция контрольной суммы (явно имеющая периодический характер). При этом были посторены гистограммы для двух размеров таблиц (`100` и `1499`). Отчетливо видно, что при размере `100` пики распределения накладываются друг на друга, увеличивая значение дисперсии с `78.7` до `1512.5`. Таким образом, можно сделать вывод, что выбор размера таблицы играет важную роль в равномерности распределения и, как следствие, оказывает влияние на скорость доступа к данным.

### Наиболее эффективная хеш-функция
Как можно заметить, при `load factor ~ 7`, наилучшее значение дисперсии (`6.3`), а значит и более равномерное распределение, показывает функция crc32. При этом наиболее близкие значения (у ror и контрольной суммы) на порядок больше и составляют `70.8` и `78.7` соответственно.

## Оптимизации хеш-таблицы
Во второй части данной работы исследуются возможности оптимизации работы хеш-таблицы. При этом предполагается, что характерным вариантом использования структуры данных является поиск значения.

